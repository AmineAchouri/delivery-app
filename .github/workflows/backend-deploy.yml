name: Backend Deploy
on:
  workflow_dispatch:
    inputs:
      env:
        description: Environment (test or prod)
        required: true
        type: choice
        options: [ test, prod ]
      feature:
        description: Feature key (folder name under infra/env/features)
        required: true
      image_tag:
        description: Optional override image tag
        required: false
  push:
    branches: [ main ]
    paths: [ "backend/**" ]

jobs:
  build-image:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      image-uri: ${{ steps.out.outputs.image }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - run: |
          cd backend
          npm ci
          npx prisma generate
          npm run build
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - id: ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Build & push
        id: out
        run: |
          TAG=${{ github.event.inputs.image_tag || format('{0}-{1}-{2}', (date +%Y%m%d%H%M%S), github.event.inputs.env, github.event.inputs.feature) }}
          IMAGE=${{ steps.ecr.outputs.registry }}/delivery-core-api:$TAG
          docker build -f backend/Dockerfile -t $IMAGE .
          docker push $IMAGE
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

  deploy-ecs:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    needs: build-image
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - name: Read feature config
        id: featurecfg
        run: |
          FILE=infra/env/features/${{ github.event.inputs.feature }}.json
          if [ ! -f "$FILE" ]; then echo "Feature config not found: $FILE" && exit 1; fi
          # Extract environment block using node (avoid jq dependency)
          node -e "const f=require('./$FILE');const e='${{ github.event.inputs.env }}';const o=f.env[e];if(!o){process.exit(1)};for(const k in o){console.log(k+'='+o[k])};console.log('FEATURE_KEY='+f.feature_key)" >> feature_env.txt
          cat feature_env.txt
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - name: Render task definition
        run: |
          . feature_env.txt
          IMAGE_URI='${{ needs.build-image.outputs.image-uri }}'
          sed -e "s|\${IMAGE_URI}|$IMAGE_URI|g" \
              -e "s|\${AWS_REGION}|us-east-1|g" \
              -e "s|\${EXEC_ROLE_ARN}|${{ secrets.ECS_EXEC_ROLE_ARN }}|g" \
              -e "s|\${TASK_ROLE_ARN}|${{ secrets.ECS_TASK_ROLE_ARN }}|g" \
              -e "s|\${SSM_DATABASE_URL_PARAM}|$SSM_DATABASE_URL_PARAM|g" \
              -e "s|\${SSM_JWT_PRIVATE_KEY_PARAM}|$SSM_JWT_PRIVATE_KEY_PARAM|g" \
              -e "s|\${SSM_JWT_PUBLIC_KEY_PARAM}|$SSM_JWT_PUBLIC_KEY_PARAM|g" \
              -e "s|\${EXTRA_FLAGS}|$EXTRA_FLAGS|g" \
              -e "s|\${DEPLOY_ENV}|${{ github.event.inputs.env }}|g" \
              -e "s|\${FEATURE_KEY}|$FEATURE_KEY|g" \
              infra/taskdef.template.json > taskdef.json
          cat taskdef.json
      - name: Register task definition
        id: reg
        run: |
          REV=$(aws ecs register-task-definition --cli-input-json file://taskdef.json --query "taskDefinition.revision" --output text)
          echo "rev=$REV" >> $GITHUB_OUTPUT
      - name: Update service
        run: |
          aws ecs update-service \
            --cluster delivery-cluster \
            --service core-api \
            --task-definition core-api-task:${{ steps.reg.outputs.rev }}
      - name: Wait stable
        run: aws ecs wait services-stable --cluster delivery-cluster --services core-api
      - name: Smoke test
        run: |
          curl -fsS https://YOUR_API_DOMAIN/health || (echo "Smoke test failed" && exit 1)

services:
  postgres:
    image: postgres:16-alpine
    env:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: delivery_app
    ports: [ "5432:5432" ]